import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { promises as fs } from 'fs';
import * as path from 'path';
import * as E from 'fp-ts/lib/Either.js';
import * as O from 'fp-ts/lib/Option.js';
import * as TE from 'fp-ts/lib/TaskEither.js';
import { pipe } from 'fp-ts/lib/function.js';
import { loadEnabledMods, resolvePluginsFromModlist, loadEnabledPlugins, ModlistEntry } from '../src/modlist.js';

describe('Modlist Loader', () => {
  const TEST_DIR = path.join(__dirname, '../test-fixtures/modlist-test');
  const MODLIST_PATH = path.join(TEST_DIR, 'modlist.txt');

  beforeAll(async () => {
    // Create test directory structure
    await fs.mkdir(TEST_DIR, { recursive: true });
    
    // Create modlist.txt
    await fs.writeFile(
      MODLIST_PATH,
      `# This file was automatically generated by Mod Organizer.
+ModA
-ModB
+ModC
`
    );

    // Create mod directories and plugins
    await fs.mkdir(path.join(TEST_DIR, 'ModA'), { recursive: true });
    await fs.mkdir(path.join(TEST_DIR, 'ModB'), { recursive: true });
    await fs.mkdir(path.join(TEST_DIR, 'ModC'), { recursive: true });

    // Create plugin files
    await fs.writeFile(path.join(TEST_DIR, 'ModA', 'plugin1.esp'), '');
    await fs.writeFile(path.join(TEST_DIR, 'ModB', 'plugin2.esp'), '');
    await fs.writeFile(path.join(TEST_DIR, 'ModC', 'plugin3.esp'), '');
  });

  afterAll(async () => {
    await fs.rm(TEST_DIR, { recursive: true, force: true });
  });

  describe('loadEnabledMods', () => {
    it('should load enabled mods in correct order', async () => {
      const result = await loadEnabledMods(MODLIST_PATH)();
      
      expect(E.isRight(result)).toBe(true);
      if (E.isRight(result)) {
        expect(result.right).toEqual(['ModA', 'ModC']);
      }
    });

    it('should handle empty modlist', async () => {
      const emptyPath = path.join(TEST_DIR, 'empty.txt');
      await fs.writeFile(emptyPath, '');
      
      const result = await loadEnabledMods(emptyPath)();
      
      expect(E.isLeft(result)).toBe(true);
      if (E.isLeft(result)) {
        expect(result.left.message).toBe('Modlist file is empty');
      }
    });

    it('should handle non-existent file', async () => {
      const result = await loadEnabledMods(path.join(TEST_DIR, 'nonexistent.txt'))();
      
      expect(E.isLeft(result)).toBe(true);
      if (E.isLeft(result)) {
        expect(result.left.message).toContain('Failed to read file');
      }
    });

    it('should handle directory path', async () => {
      const result = await loadEnabledMods(TEST_DIR)();
      
      expect(E.isLeft(result)).toBe(true);
      if (E.isLeft(result)) {
        expect(result.left.message).toContain('Path is not a file');
      }
    });
  });

  describe('resolvePluginsFromModlist', () => {
    it('should find plugins in enabled mods', async () => {
      const result = await resolvePluginsFromModlist(MODLIST_PATH, ['plugin1.esp', 'plugin3.esp'])();
      
      expect(E.isRight(result)).toBe(true);
      if (E.isRight(result)) {
        const plugins = result.right as ModlistEntry[];
        expect(plugins).toHaveLength(2);
        expect(plugins[0]).toEqual({
          filename: 'plugin1.esp',
          loadOrder: 0,
          fullPath: path.join(TEST_DIR, 'ModA', 'plugin1.esp'),
          modFolder: 'ModA'
        });
        expect(plugins[1]).toEqual({
          filename: 'plugin3.esp',
          loadOrder: 1,
          fullPath: path.join(TEST_DIR, 'ModC', 'plugin3.esp'),
          modFolder: 'ModC'
        });
      }
    });

    it('should handle case-insensitive plugin names', async () => {
      const result = await resolvePluginsFromModlist(MODLIST_PATH, ['PLUGIN1.ESP'])();
      
      expect(E.isRight(result)).toBe(true);
      if (E.isRight(result)) {
        const plugins = result.right as ModlistEntry[];
        expect(plugins).toHaveLength(1);
        expect(plugins[0].filename).toBe('PLUGIN1.ESP');
      }
    });

    it('should fail when plugin not found in any enabled mod', async () => {
      const result = await resolvePluginsFromModlist(MODLIST_PATH, ['nonexistent.esp'])();
      
      expect(E.isLeft(result)).toBe(true);
      if (E.isLeft(result)) {
        expect(result.left.message).toContain('Some plugins not found');
      }
    });

    it('should fail when plugin is only in disabled mod', async () => {
      const result = await resolvePluginsFromModlist(MODLIST_PATH, ['plugin2.esp'])();
      
      expect(E.isLeft(result)).toBe(true);
      if (E.isLeft(result)) {
        expect(result.left.message).toContain('Some plugins not found');
      }
    });

    it('should handle multiple plugins with some missing', async () => {
      const result = await resolvePluginsFromModlist(
        MODLIST_PATH,
        ['plugin1.esp', 'nonexistent.esp', 'plugin3.esp']
      )();
      
      expect(E.isLeft(result)).toBe(true);
      if (E.isLeft(result)) {
        expect(result.left.message).toContain('nonexistent.esp');
      }
    });
  });
});

describe('loadEnabledPlugins', () => {
  const TEST_DIR = path.join(__dirname, '../test-fixtures/plugins-test');
  const PLUGINS_PATH = path.join(TEST_DIR, 'plugins.txt');

  beforeAll(async () => {
    await fs.mkdir(TEST_DIR, { recursive: true });
    await fs.writeFile(
      PLUGINS_PATH,
      `*PluginA.esp\nPluginB.esm\n*PluginC.esp\n*PluginD.esm\n` // PluginB is disabled
    );
  });

  afterAll(async () => {
    await fs.rm(TEST_DIR, { recursive: true, force: true });
  });

  it('should load enabled plugins in order', async () => {
    const result = await loadEnabledPlugins(PLUGINS_PATH)();
    expect(E.isRight(result)).toBe(true);
    if (E.isRight(result)) {
      expect(result.right).toEqual(['PluginA.esp', 'PluginC.esp', 'PluginD.esm']);
    }
  });

  it('should handle empty plugins.txt', async () => {
    const emptyPath = path.join(TEST_DIR, 'empty.txt');
    await fs.writeFile(emptyPath, '');
    const result = await loadEnabledPlugins(emptyPath)();
    expect(E.isRight(result)).toBe(true);
    if (E.isRight(result)) {
      expect(result.right).toEqual([]);
    }
  });

  it('should ignore whitespace and comments', async () => {
    const commentPath = path.join(TEST_DIR, 'commented.txt');
    await fs.writeFile(commentPath, '  *PluginA.esp  \n# Comment\n   *PluginB.esm\n');
    const result = await loadEnabledPlugins(commentPath)();
    expect(E.isRight(result)).toBe(true);
    if (E.isRight(result)) {
      expect(result.right).toEqual(['PluginA.esp', 'PluginB.esm']);
    }
  });
}); 